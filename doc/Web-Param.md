# NAME

Clib::Web::Param - Парсинг параметров GET/POST запроса.

# SYNOPSIS

    use Clib::Web::Param;
    
    my $p = web_param(prepare => 1);
    
    my $val = $p->raw('param');

# Простые функции

Эти функции не импортируются (вызвать их можно через `Clib::Web::Param::fff()`).

## url\_data($query)

Разбирает строку в формате query-string: field1=val1&fi1ld2=val2...

На выходе: хэш "ключ-значение"

    my %p = Clib::Web::Param::url_data($query)

## data2url(%fields)

Собирает из хеша ключ-значение обратно query-string: field1=val1&fi1ld2=val2...

    my $query = Clib::Web::Param::data2url(
                field1 => 'val1',
                field2 => 'val2',
            );

## url\_encode($string)

Преобразует строку $string в URL-формат, где все спецсимволы заменены на формат %xx

    my $url = Clib::Web::Param::url_encode('Hello World');
    
    # $url = 'Hello%20World';

## url\_decode($string)

Обратное преобразование строки из URL-формата, где все спецсимволы заменены на формат %xx

    my $str = Clib::Web::Param::url_decode('Hello%20World');
    
    # $str = 'Hello World';

# Импортируемые функции

## web\_paramerr()

Возвращает ошибки при парсинге GET/POST-запросов.

## web\_param(...)

Парсит GET/POST-запрос.

В простом варианте возвращает хеш ключ-значение параметров запроса.

    use Clib::Web::Param;
    
    my %p = web_param();
    
    my $val1 = $p{field1};

Параметры вызова:

- Флаг `prepare` - В этом случае `web_param(...)` вернёт объект, который позволит
более гибко работать с полученными параметрами.
- `file` - Хеш, где ключ - имя поля, а значение - что делать в случае,
если под этим полем мы загружаем файл.

    Если значение: скаляр - это будет считаться именем файла, в который надо записать данные.

    Если значение: ссылка на скаляр - в этот скаляр будут загружены данные этого файла без сохранения на диск.

## web\_cookie(...)

Парсит COOKIE-данные.

В простом варианте возвращает хеш ключ-значение параметров запроса.

    use Clib::Web::Param;
    
    my %p = web_cookie();
    
    my $val1 = $p{field1};

Параметры вызова:

- Флаг `prepare` - В этом случае `web_cookie(...)` вернёт объект, который позволит
более гибко работать с полученными параметрами.

## web\_cookieset(key => 'val', ... доп параметры ...)

Запоминает глобально, какие cookie надо будет отправить в ответ на запрос.

Необязательные дополнительные параметры (хэш "ключ-значение"):

- `domain` - домен, в котором должны действовать этот куки.
- `path` - относительный путь url, для которого будут действовать этот куки.
- `permanent` - флаг (значение: 1/0), делающий этот куки постоянным.
На самом деле выставляется `expire=10-Feb-2099`
- `expires` - дата время, когда будет удалён куки. Формат: `Wed, 10-Feb-2099 00:00:00 GMT`
- `delete` - флаг (значение: 1/0), означающий удаление куки с помощью выставления
`expire=01 Jan 1970`

## web\_cookiebuild()

Возвращает хеш из запомненных куки с помощью `web_cookieset()` в формате HTTP-заголовков.

# Методы класса `Clib::Web::Param::Prepare`

Объект этого класса будет возвращён функциями `web_param(...)` или `web_cookie(...)`,
если указать параметр `prepare =` 1>.

## exists($key)

Вернёт 1, если параметр с указанным именем существует

## keys()

Вернёт массив всех ключей в том порядке, в котором они встретились. Повторно встреченные ключи
будут повторяться в возвращаемом списке.

## orig()

Вернёт хеш `ключ-значение` всех ключей и их значений в первоначальном порядке.

## exp($key1, $key2...)

Вернёт хеш `ключ-значение` всех переданных в аргументах параметров в первоначальном порядке.

Вызов метода без аргументов идентичен методу orig().

## rebuild($key1 => 'val1')

Пересборка обратно в формат QUERY\_STRING. Если в аргументах указан хеш, то все исходные параметры
с указанными именами будут пропущены и добавлены в конец этой строки с новыми значениями.

## raw($key)

Оригинальное значение параметра.

Если с именем `$key` встречалось более одного параметра, то будет возвращено первое встретившееся значение.

## int($key)

Значение параметра в числовом формате. Если значение начиналось с цифр, но содержит не только цифры,
оно будет преобразовано в число по правилам perl. Если значение параметра было не числом, будет возвращён ноль.

Возвращаемое значение всегда defined.

Если с именем `$key` встречалось более одного параметра, то будет возвращено первое встретившееся значение.

## uint($key)

Значение параметра в числовом формате. Отрицательное число станет нулём.

Если с именем `$key` встречалось более одного параметра, то будет возвращено первое встретившееся значение.

## float($key)

Значение параметра в дробном формате.

Возвращаемое значение всегда defined.

Если с именем `$key` встречалось более одного параметра, то будет возвращено первое встретившееся значение.

## ufloat($key)

Значение параметра в дробном формате. Отрицательное число станет нулём.

Если с именем `$key` встречалось более одного параметра, то будет возвращено первое встретившееся значение.

## code($key)

Значение, в котором будут отброшены любые символы кроме букв и цифр.

Возвращаемое значение всегда defined.

Если с именем `$key` встречалось более одного параметра, то будет возвращено первое встретившееся значение.

## str($key)

Значение, в котором будут отброшены любые пробельные символы в начале и в конце строки.

Возвращаемое значение всегда defined.

Если с именем `$key` встречалось более одного параметра, то будет возвращено первое встретившееся значение.

## bool($key)

Вернёт 1, если исходное значение было параметра: y, yes, on. Во всех остальных случаях вернёт 0.

Возвращаемое значение всегда defined.

Если с именем `$key` встречалось более одного параметра, то будет возвращено первое встретившееся значение.

## all($key)

Вернёт все значения параметра `$key`, встретившиеся в первоначальном порядке.

## allXXX($key)

Все методы с префиксом all (например: allint($key)) возвращают значения в том же формате,
что их короткие варианты. Но в данном случае будут возвращены все значения указанного параметра,
встретившиеся в первоначальном порядке.

Эти методы всегда возвращают массив. Поэтому в скалярном контексте там будет всегда количество элементов,
а не значение.
