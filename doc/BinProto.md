# NAME

Clib::BinProto - Класс для шаблонного конвертирования данных в бинарный формат и обратно.

# SYNOPSIS

    use Clib::BinProto;
    
    my $proto = Clib::BinProto->new(
        '%', # Заголовок пакета
        # шаблоны:
        { s => 0x01, code => 'hello', pk => 'Na32', key => 'authid,login' },
        { s => 0x02, code => 'bye',   pk => '',     key => '' },
    );
    
    my $bin =
        $proto->pack(
            hello   => { authid => 100, login => 'test' },
            bye     => {}
        );
    
    my $datalist = $proto->unpack( $bin );
    
    # содержимое $data:
    #   [
    #       { code => 'hello', authid => 100, login => 'test' }
    #       { code => 'bye' }
    #   ]

# Коды форматирования

- `C` - 1-байтовое целое
- `n` - 2-байтовое целое
- `N` - 4-байтовое целое
- `c` - 1-байтовое знаковое
- `i` - 2-байтовое знаковое
- `I` - 4-байтовое знаковое
- `v` - IP v4 адрес
- `T` - DateTime
- `t` - DateTime + в конце 1/100 секунды
- `f` - %0.2float
- `D` - double (64bit)
- `x` - hex16
- `X` - hex32
- `H` - hex64
- `a` - символ (строка в 1 байт)
- `aDD` - строка фиксированной длины, ограниченная DD символами
- `пробел` - один зарезервированный байт (без привязки к ключу)
- `S` - динамическая строка, где длина строки - 2 байта
- `s` - динамическая строка, где длина строки - 1 байт

# Структура бинарного пакета

Для каждой команды/шаблона:

    (заголовок)[1 байт] (команда/шаблон)[1 байт] (длина данных)[2 байта] (данные)

- Заголовок \[1 байт\] - Любой символ, указывается самым первым аргументов в методах new/init.
Этот символ одинаковый для всех шаблонах для данного объекта-протокола. Участвует в валидации
валидности протокола при распаковке.
- Команда/шаблон \[1 байт\] - при инициализации шаблона указывается в параметре "s" - однобайтовое целое число.
- Длина данных \[2 байта\] - длина бинарных данных (не всего пакета, а только данных)
в "network" (big-endian) формате.
- Данные - бинарная последовательность, упакованная согласно формату в параметре "pk" шаблона.

# Методы

## new($header, шаблон1, ... шаблон-N)

Создание объекта с описанием протокола.

Первый аргумент - это односимвольный заголовок. Это может быть любым символом и даже непечатаемым байтом.
С этого байта будет начинаться каждый пакет.

Под пакетом подразумевается одна команда, или некая одномерная структура данных, упакованная по определённому шаблону.

Все последующие аргументы - это перечисление шаблонов списком хешей. Каждый шаблон - это один хеш: 

    { параметры }

Параметры шаблона:

- `code` - имя шаблона, использыется для удобно-читаемого указания в коде.
- `s` - код шаблона/команды, однобайтовое целое число - именно этот байт будет вторым в пакете.
- `pk` \[необязательный\] - шаблон заполнения пакета данными, синтаксис похож на формат-аргумент команды pack в perl.
- `key` \[необязательный\] - строка, где через запятую перечислены имена полей, которые упакованы по формату `pk`.

По сути: `code` является символьным представлением бинарного кода `s`,
а `key` - это имена полей, которые упаковываются в той же последовательности по формату `pk`.

Количество полей в `key` должно соответствовать числу бинарный полей в `pk`, иначе будет ошибка инициализации.

## error()

Возвращает текст ошибки в случае неудачного выполнения команд:
инициализации шаблонов `new()`/`init()`/`add()`, упаковки `pack()` или распаковки `unpack()`.

В списковом контексте возвращает все ошибки, возникшие за время выполнения ^^^вышеуказанных функций.

В скалярном контексте влзвращает только последнюю ошибку.

## errclear()

Очищает список ошибок, обнаруженных ранее. Однако, при выполнении функций:
инициализации шаблонов `new()`/`init()`/`add()`, упаковки `pack()` или распаковки `unpack()` -
этот метод вызывается автоматически и так, поэтому, как правило, дополнительный вызов не требуется.

## init(шаблон1, ... шаблон-N)

Инициализация шаблонов. Выполняет полный сброс текущих шаблонов и добавление новых.
Параметры вызова соответствуют вызову метода `new()`, но без первого аргумента `$header`.

## add(параметры-шаблона)

Добавление одного шаблона. Сброса текущих шаблонов не происходит.

При этом, заворачивать параметры в ссылку на хеш не требуется:

    $proto->add(
        s       => 0x01,
        code    => 'hello',
        pk      => 'Na32',
        key     => 'authid,login'
    );

## del($code)

Удаление шаблона с именем `$code`.

Возвращает true, если пакет был в списке шаблонов объекта,
и undef - если шаблона с таким именем не существовало.

## pack(данные)

Упаковка данных по шаблону.

Данные могут быть представлены либо отдельным указанием имени шаблона и хешем данных:

    $proto->pack(
        имя_шаблона => { данные }
    );

либо хешем, внутри которого указано имя шаблона в поле `code`:

    $proto->pack(
        { code => 'имя_шаблона', данные }
    );

За один вызов метода можно указать неограниченное количество пакетов с данными, все они будут
соединены в одну бинарную строку.

Длина бинарного пакета всегда соответствует тому, что указано в параметре `pk` шаблона, по которому
упаковывается этот пакет. А в исходных данных, подставляемых для упаковки, должны присутствовать все
поля, указанные в `key` шаблона.

## unpack($binstr)

Распаковка данных из бинарного потока.

В случае успеха распаковки возвращает ссылку на список хешей с распакованными данными:

    [
        { code => 'hello', authid => 100, login => 'test' }
        { code => 'bye' }
    ]

В случае ошибки распаковки возвращает `undef`.

Т.к. в бинарном пакете указана фактическая длина данных, то пакет не будет распаковываться,
пока в исходной строке не будет передана вся ожидаемая длина.

Если пакет полностью присутствует, то он будет вырезан из исходной строки `$binstr`.
Это удобно для обработки входящего потока данных.

Фактическая длина данных в пакете может оказаться длиннее или короче того, что указано
в `pk` шаблона. Это никак не повлияет на целостность потока распаковываемых данных, т.к.
длина бинарного пакета будет определена исходя именно из длины, указанной в самом пакете,
а не из `pk` шаблона. При этом, бинарный код, который окажется длинее указанного в `pk` шаблона,
будет проигнорирован. А если бинарный код окажется короче ожидаемого, то поля, в недостающем участке
будут отсутствовать в возвращаемом хеше с данными для этого пакета.
