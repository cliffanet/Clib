# NAME

Clib::DB::MySQL - обвязка на модуль DBI для структурированных MySQL-запросов

# SYNOPSIS

    use Clib::DB::MySQL 'DB';
    
    my @all = sqlAll('cmdperiodic');
    
    my @dev = sqlSrch(device => deleted => 0);

# Подключение

Для директивы `use` после имени модуля можно указать имя комфиг файла.
По умолчанию конфиг берётся из файла DB.pm корня проекта.

Если перед этим был подключен модуль `Clib::Proc`, то корень проекта определяется этим модулем,
иначе будет попытка открыть файл из текущей рабочей директории.

Формат файла - содержимое хеша "ключ-значение", определяющего параметры подключения.

Параметры, указываемые в DB.pm:

- `utf8` - флаг, сообщающий об использовании utf-кодировки в качестве основной.
- `connect` - аргументы подключения к базе данных. Значение - хеш "ключ-значение",
в котором перечислены необходимые для подключения поля: `host`, `sock`, `user`, `pass`, `name`.

    Если подключен модуль `Clib::Const`, в качестве значения этого параметра можно использовать
    скаляр - он будет интерпретирован как имя параметра в конфиг-файле, в значении которого и будут указаны
    необходимые параметры подключения к базе данных.

    По умолчанию настройки берутся из конфиг параметра `db`. Пример в const.conf:

        db => {
            host    => 'localhost',
            name    => 'dbname',    # Имя базы данных
            user    => 'login',     # Имя пользователя
            pass    => 'password',  # Пароль доступа
        },

- `args` - хеш "ключ-значение" с дополнительными параметрами, который будет передан четвёртым аргументом в 
DBI->connect($connectstr, $user, $pass, { %$args }).
- `onconnect` - массив с MySQL-командами, которые надо выполнить сразу после подключения к серверу.
- `tbl` - список таблиц, доступных для структурированных запросов. Список обязателен к заполнению, иначе
при попытке обратиться к таблице получим ошибку "unknown table".

    Если список перечислен массивом, то имена таблиц регистрируются как есть.

    Можно указать хеш: "псевдоним" => "реальное имя таблицы".

# Импортируемые функции

## sqlDo($sql, @param)

Прямое выполнение SQL-запроса. Если в `$sql` используются вставки "?", то в @param перечислены
все значения для этих вставок в том же порядке.

Возвращает количество затронутых строк. Выражение всегда `true`, если запрос выполнен успешно,
даже если не затронуто ни одной строки (значение '0E0').

## sqlQueryList($sql, @param)

Прямое выполнение SQL-запроса для получения данных.
Если в `$sql` используются вставки "?", то в @param перечислены
все значения для этих вставок в том же порядке.

Среди @param можно указать хеш, он будет воспринят как ["$pager = { ... }"](#pager).

## sqlSrch($tbl, ...)

Структурированный запрос на выборку данных из таблицы `$tbl`. В качестве простых условий выборки используется
"поле" => "значение" - склейка указанных значений будет по условию `AND`. Расширенный список возможных параметров
выборки указан ниже в разделе ["Дополнительные функции для параметрического запроса sqlSrch(...)"](#дополнительные-функции-для-параметрического-запроса-sqlsrch).

Возвращает список хешей "ключ-значение" со всеми полями (колонками) таблицы.

## sqlFunc($tbl, $sqlSel, ...)

Функция-аналог для `sqlSrch($tbl, ...)`, но с уточнением списка полей (колонок) `$sqlSel` в формате MySQL, который
будет вставлен между `SELECT` и `FROM` в запросе.

Синтаксис параметров для выборки идентично функции `sqlSrch($tbl, ...)`.

## sqlCount($tbl, ...)

Возвращает вызов функции:

    sqlFunc($tbl, 'COUNT(*)', ...);

## sqlMax($tbl, $fld, ...)

Возвращает вызов функции:

    sqlFunc($tbl, 'MAX(`'.$fld.'`)', ...);

## sqlGet($tbl, $fld, $id)

Возвращает строки по значению одного поля. Если `$fld` не указан (указано только два аргумента),
то выборка производится по полю `` `id` ``.

По возможности возвращает скаляр. Но если возвращаемых строк более одной,
то возвращает список даже в скалярном контексте.

## sqlAll($tbl, @orderby)

Получение всех строк таблицы. В `@orderby` перечислены все поля, по которым надо
сортировать результат. По умолчанию для каждого поля применяется прямая сортировка,
но если перед именем поле указан "-" (минус), для этого поля будет применена
обратная сортировка.

## sqlAdd($tbl, fld1 => 'val1', fld2 => 'val2', ...)

Добавление строки в таблицу.

Возвращает `ID` добавленной строки.

## sqlRep($tbl, fld1 => 'val1', fld2 => 'val2', ...)

То же, что и `sqlAdd(...)`, но вместо `INSERT` делает `REPLACE`

## sqlUpd($tbl => $id, fld1 => 'val1', fld2 => 'val2', ...)

Меняет значения полей для строки, где поле `` `id` `` равно `$id`

## sqlUpdf($tbl, $fld => $id, fld1 => 'val1', fld2 => 'val2', ...)

То же, что и `sqlUpd`, если в качестве ключевого поля надо применить
какое-то другое, указав его в `$fld`

## sqlSet($tbl, $fld => $id, fld1 => 'val1', fld2 => 'val2', ...)

Сначала пытается делать `UPDATE` по полю `$fld`, и если оказывается,
что затронутых строк нет, тогда делает `INSERT` с указанием всех полей,
включая `$fld`.

Т.е. это некоторый аналог `INSERT UPDATE`.

## sqlDel($tbl, $fld, $id)

Удаляет строки, где `$fld=$id`. Если `$fld` не указано (только два аргумента),
то в качестве ключевого поля применяется `` `id` ``.

## sqlConnect()

Подключение к базе данных.

Возвращает $dbh.

Необходимости вызывать эту функцию нет. Она будет вызвана автоматически  при любом запросе по необходимости.

## sqlDisconnect()

Принудительное отключение от базы данных.

## sqlPing()

Проверка соединения до базы данных.

## sqlPreFork()

Выполняется перед необходимостью сделать fork() в текущем процессе.

Если в Main-процессе не выполняется никаких SQL-запросов, то вызов этой функции не требуется.

## sqlMainFork()

Выполняется после вызова fork() в Main-процессе.

## sqlChldFork()

Выполняется после вызова fork() в дочернем процессе, если в нём необходимо выполнение SQL-запросов.

Будет выполнен метод `$dbh-`clone();>

# Дополнительные функции для параметрического запроса sqlSrch(...)

    my @sess =
        sqlSrch(
            session =>
            uid => $uid,
            sqlNotEq(id => $sid),
            sqlNull('deauth')
        );
    # SELECT `session`.* FROM `session` WHERE (uid = $uid) AND (`id` != $sid) AND (`deauth` IS NOT NULL);
    
    my ($user) =
        sqlSrch(
            user =>
            id => $user->{id},
            sqlPassword(password => $password)
        );
    # SELECT `user`.* from `user` WHERE (`id` = $user->{id}) AND (PASSWORD(`password`) = $password);
    
    my @dev =
        sqlSrch(
            device =>
            deleted => 0,
            sqlLike(name => '%' . $txt . '%')
    );

## sqlOr(fld1 => $val1, fld2 => $val2)

    (`fld1` = $val1) OR (`fld2` = $val2)

## fld => \[$val1, $val2\]

    (`fld` = $val1) OR (`fld` = $val2)

## sqlAnd(fld1 => $val1, fld2 => $val2)

    (`fld1` = $val1) AND (`fld2` = $val2)

## fld1 => $val1, fld2 => $val2

    (`fld1` = $val1) AND (`fld2` = $val2)

## sqlEq(fld => $val)

    `fld` = $val

## sqlNotEq(fld => $val)

    `fld` != $val

## sqlLike(fld => $val)

    `fld` LIKE $val

## sqlGt(fld => $val)

    `fld` > $val

## sqlGE(fld => $val)

    `fld` >= $val

## sqlLt(fld => $val)

    `fld` < $val

## sqlLE(fld => $val)

    `fld` <= $val

## sqlOldest(fld => $val)

    `fld` < DATE_SUB(NOW(), INTERVAL $val SECOND)

## sqlLater(fld => $val)

    `fld` >= DATE_SUB(NOW(), INTERVAL $val SECOND)

## sqlOldNow(fld)

    `fld` < NOW()

## sqlNull(fld)

    `fld` IS NULL

## sqlNotNull(fld)

    `fld` IS NOT NULL

## sqlPassword(fld => $val)

    PASSWORD(`fld`) = $val

# Дополнительные функции-опции запроса sqlSrch(...)

    my $pager = { onpage => 100 };
    
    my @list =
        sqlSrch(
            history =>
            $pager,
            @where,
            sqlOrder(qw/-dtbeg -id/)
        );

## $pager = { ... }

Если передать хеш с полем `onpage`, это будет воспринято как необходимость использовать pager.

Поля `$pager`, используемые в самом запросе (как аргументы):

- `onpage` - количество записей на странице
- `page` - текущая страница (нумерация с 1..)
- `start` - \[взаимоисключается с `page`\] запись, с которой начинать выборку (нумерация с 0..)

После запроса в этот хеш будут добавлены поля:

- `page` - текущая страница - если не была указана изначально, будет равна 1.
- `start` - порядковый номер записи, с которой началась выборка - это не `id`, а какая по счёту запись.
- `count` - получено записей на выбранной странице.
- `countall` - всего доступно записей в выборке.
- `pageall` - всего страниц в выборке.

## sqlOrder('fld1', 'fld2', ...)

Сортировка по указанным полям. По умолчанию для каждого поля применяется прямая сортировка,
но если перед именем поле указан "-" (минус), для этого поля будет применена
обратная сортировка.

## sqlGroup('fld1', 'fld2', ...)

Группировка записей по указанным полям

## sqlLimit($n) или sqlLimit($start, $n)

Ограничение вывода количеством записей `$n`, начиная с `$start`.
